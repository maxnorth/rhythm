// Flow v2 Grammar - Minimal Phase 1
// Supports: async function workflow definition OR single statement (legacy)

program = { SOI ~ (workflow_function | statement) ~ EOI }

// Workflow function definition
workflow_function = { "async" ~ "function" ~ identifier ~ "(" ~ param_list? ~ ")" ~ block }

param_list = { identifier ~ ("," ~ identifier)* }

block = { "{" ~ statement* ~ "}" }

// Statements
statement = { return_stmt | if_stmt | while_stmt | try_stmt | break_stmt | continue_stmt | block | assign_stmt | expr_stmt }

return_stmt = { "return" ~ expression }

assign_stmt = { identifier ~ ("." ~ identifier)* ~ "=" ~ expression }

if_stmt = { "if" ~ "(" ~ expression ~ ")" ~ block ~ else_clause? }
else_clause = { "else" ~ (if_stmt | block) }

while_stmt = { "while" ~ "(" ~ expression ~ ")" ~ block }

try_stmt = { "try" ~ block ~ "catch" ~ "(" ~ identifier ~ ")" ~ block }

break_stmt = { "break" }
continue_stmt = { "continue" }

expr_stmt = { expression }

// Identifiers
identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

expression = { await_expr | call_expr }

// Await expression: await foo(), await task
await_expr = { "await" ~ expression }

// Function calls: foo(), foo.bar(), foo(1, 2, 3)
call_expr = { member_expr ~ call_suffix? }

call_suffix = { "(" ~ arg_list? ~ ")" }

arg_list = { expression ~ ("," ~ expression)* }

// Member access: foo, foo.bar, foo.bar.baz
member_expr = { primary ~ ("." ~ identifier)* }

primary = {
    literal
    | identifier
}

literal = {
    object_lit
    | array_lit
    | boolean
    | number
    | string
    | null_lit
}

// Object literal: { key: value, key2: value2 }
object_lit = { "{" ~ property_list? ~ "}" }
property_list = { property ~ ("," ~ property)* ~ ","? }
property = { identifier ~ ":" ~ expression }

// Array literal: [1, 2, 3]
array_lit = { "[" ~ element_list? ~ "]" }
element_list = { expression ~ ("," ~ expression)* ~ ","? }

// Literals
number = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
boolean = { "true" | "false" }
string = { "\"" ~ string_content ~ "\"" }
string_content = @{ (!("\"") ~ ANY)* }
null_lit = { "null" }

// Whitespace and comments
WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ line_comment | block_comment }
line_comment = { "//" ~ (!"\n" ~ ANY)* }
block_comment = { "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
