//! Outbox for side effects
//!
//! The outbox pattern allows the executor to record side effects (like task creation
//! or timer scheduling) without actually performing them. The external orchestrator
//! is responsible for processing the outbox after execution.

use super::types::Val;
use crate::types::ExecutionType;
use chrono::{DateTime, Utc};
use std::collections::HashMap;

/// An execution creation side effect
///
/// Represents a request to create a new task or workflow execution. This is added
/// to the outbox when Task.run() or Workflow.run() is called, and the external
/// orchestrator will batch-create these executions.
#[derive(Debug, Clone, PartialEq)]
pub struct ExecutionCreation {
    /// The unique ID for this execution (UUID generated by Task.run/Workflow.run)
    pub id: String,

    /// The name of the workflow/task to run
    pub target_name: String,

    /// The inputs to pass to the execution
    pub inputs: HashMap<String, Val>,

    /// The type of execution (Task or Workflow)
    pub target_type: ExecutionType,
}

impl ExecutionCreation {
    /// Create a new execution creation side effect
    pub fn new(
        id: String,
        target_name: String,
        inputs: HashMap<String, Val>,
        target_type: ExecutionType,
    ) -> Self {
        Self {
            id,
            target_name,
            inputs,
            target_type,
        }
    }
}

/// A timer scheduling side effect
///
/// Represents a request to schedule a timer. This is added to the outbox
/// when Timer.delay() is called, and the external orchestrator will create
/// a scheduled_queue entry.
#[derive(Debug, Clone, PartialEq)]
pub struct TimerSchedule {
    /// The absolute time when the timer should fire
    pub fire_at: DateTime<Utc>,
}

impl TimerSchedule {
    /// Create a new timer schedule side effect
    pub fn new(fire_at: DateTime<Utc>) -> Self {
        Self { fire_at }
    }
}

/// A signal request recorded during workflow execution
///
/// Represents a request to wait for a signal. The claim_id uniquely identifies
/// this request for idempotent matching with incoming signals.
#[derive(Debug, Clone, PartialEq)]
pub struct SignalRequest {
    /// Unique identifier linking request to signal
    pub claim_id: String,
    /// The signal channel name
    pub signal_name: String,
    /// Set when matched to an unclaimed signal (during pre-loop or commit)
    pub signal_id: Option<String>,
}

impl SignalRequest {
    /// Create a new signal request
    pub fn new(claim_id: String, signal_name: String) -> Self {
        Self {
            claim_id,
            signal_name,
            signal_id: None,
        }
    }
}

/// Outbox - collection of side effects
#[derive(Debug, Clone, Default)]
pub struct Outbox {
    /// Execution creation side effects (tasks and workflows)
    pub executions: Vec<ExecutionCreation>,
    /// Timer scheduling side effects
    pub timers: Vec<TimerSchedule>,
    /// Signal request side effects
    pub signals: Vec<SignalRequest>,
}

impl Outbox {
    /// Create a new empty outbox
    pub fn new() -> Self {
        Self {
            executions: Vec::new(),
            timers: Vec::new(),
            signals: Vec::new(),
        }
    }

    /// Add an execution creation side effect
    pub fn push_execution(&mut self, execution: ExecutionCreation) {
        self.executions.push(execution);
    }

    /// Add a timer schedule side effect
    pub fn push_timer(&mut self, timer: TimerSchedule) {
        self.timers.push(timer);
    }

    /// Check if an execution with the given ID is in the outbox
    pub fn has_execution(&self, execution_id: &str) -> bool {
        self.executions.iter().any(|e| e.id == execution_id)
    }

    /// Add a signal request side effect
    pub fn push_signal(&mut self, signal: SignalRequest) {
        self.signals.push(signal);
    }

    /// Find a signal request by claim_id
    pub fn get_signal(&self, claim_id: &str) -> Option<&SignalRequest> {
        self.signals.iter().find(|s| s.claim_id == claim_id)
    }
}
